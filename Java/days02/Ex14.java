package days02;

/**
 *@author 송해영
 *@date 2023. 7. 16.-오후 8:28:24
 *@subject ㄴ. 실수계열 - float(4), [double(8)]
 *@content
 */
public class Ex14 {

	public static void main(String[] args) {
		
		                      //부호비트자리     2^3지수값이 저장됨     
		float f ;  // 32비트 [[0]       [00000000 8자리는 지수값]     [00000000000000000000000 23 가수]]
																				//(23자리 가수에는 아래에 나와있는 1.000아래 소숫점이 23개 들어감)
		double d ; // 64비트 [[0][00000000000 11지수][0000000000000000000000000000000000000000000000000000 52 가수]
		
		// 정수 10 -> 0000 1010 으로 저장 (2진법)
		// 음수 -10 -> 2의 보수법 -> 1111 0110
		// 문자 'A' -> 65 (문자코드표에 의해) -> 00000000 01000001
		
		// 실수 9.1234567(유한소수) 가 float나 double로 어떻게 저장되는지?
		// 9를 2진수로 나타내면 1001
		// 0.1234567 부분은 2를 곱해서 소수점 떨어질때까지 하면 2진수로 됨 -> 2진수로 바꾸면 유한 소수에서 무한소수가 됨
		// 이러한 무한소수를 float이나 double 은 32비트(23가수자리만큼 잘림)나 64비트(52자리)만큼 잘라서 저장하고 나면 오차가 생길수밖에없다
		
		// 1001.000111111001101011011011.....무한함
		// 1.XXX   x 2^n  정규화 (2진수니까 2고 세자리라 3)
		// 1.001000111111001101011011011..... x 2^3
		//실수는 소숫점 뒤에 자리가 잘릴수있기 때문에 오차가 있는 자료형이다
		
		// 모든 실수 자료형  double 기본으로 사용하자. (오차가 float보다 덜 한 double로)
		// float pi = 3.14;를 치면 Type mismatch: cannot convert from double to float라는 에러가 뜸
		//3.14를 8바이트 double로 인식해서 생기는 오류
		float pi = 3.14f; //접미사 f를 붙이면 형변환 할 필요없이 해결됨
		// float pi = (float) 3.14; (형변환해서 에러 해결)
		// double pi = 3.14; (자료형을 double로 바꿔 해결)
		
		System.out.printf("pi = %f", pi); //f는 소수점 6자리까지 출력
	}//main

}//class
