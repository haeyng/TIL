### 기본형 매개변수의 개념과 예제
- 기본형 매개변수 - 변수의 값을 읽기만 할 수 있다. (값 변경 불가)

```java
package study;

class Data{ int x; }
class Ex6_6{
    public static void main(String [] args){ 
        //1. main 메서드가 스택에 올라간다. 프로그램 시작
    	
        Data d = new Data();//3.멤버가 x 한개인 Data 객체 생성

        d.x = 10; //2. 참조변수 d가 main 메서드가 있는 스택에 만들어진다. 
        //4. Data 객체의 주소값이 d에 저장되고 참조변수 d가 객체를 가리키게 된다.
        //5. 참조변수 d가 가리키는 객체 멤버 x의 값이 10으로 저장.
        
        System.out.println("main() : x = " + d.x); //main() : x = 10

        change(d.x);//6.메서드 호출
        //9.change 메서드가 종료되고 호출했던 곳으로 되돌아 온다. change 메서드는 호출스택에서 사라지고 main메서드가 실행상태로 된다.
        
        System.out.println("After change(d.x)");
        System.out.println("main() : x = " + d.x);//main() : x = 10
        //10. 스택에 있는 참조변수 d가 가리키는 x의 값은 10
        //11. println이 호출되기 전에 d.x의 값이 먼저 계산이 끝나고 출력된다.
        //12. println이 실행되어 출력된 후에 스택에서 사라지고 main 메서드도 종료된다.
    }//main

    static void change(int c){//7.d.x값이 change의 기본형 매개변수 c에 복사 된다. c = 10
        c = 1000; //8. 지역변수 c가 1000으로 저장. c가 10 ->1000 변경
        System.out.println("change() : c = " + c); //change() : c = 1000
    } 
}//class
```

### 참조형 매개변수의 개념과 예제
- 참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다.

```java
package study;

class Data{ int x; }
class Ex6_7{
    public static void main(String [] args){ //1. main 메서드가 스택에 올라간다. 프로그램 시작
    	
        Data d = new Data();//3.멤버가 x 한개인 Data 객체 생성
        d.x = 10; //2. 참조변수 d가 main 메서드가 있는 스택에 만들어진다. 
        //4. Data 객체의 주소값이 d에 저장되고 참조변수 d가 객체를 가리키게 된다.
        //5. 참조변수 d가 가리키는 객체 멤버 x의 값이 10으로 저장.
        
        System.out.println("main() : x = " + d.x); //main() : x = 10

        change(d);//6.메서드 호출
        //9.change 메서드가 종료되고 호출했던 곳으로 되돌아 온다. 
        //change 메서드는 호출스택에서 사라지고(참조변수 c도 사라진다) main메서드가 실행상태로 된다.
        
        System.out.println("After change(d)");
        System.out.println("main() : x = " + d.x);//main() : x = 1000
        //10. 스택에 있는 참조변수 d가 가리키는 x의 값은 1000
        //11. println이 호출되기 전에 d.x의 값이 먼저 계산이 끝나고 출력된다.
        //12. println이 실행되어 출력된 후에 스택에서 사라지고 main 메서드도 종료된다.
    }//main

    static void change(Data c){//7.d의 주소값이 change의 참조형 매개변수 c에 복사 된다.
        c.x = 1000; 
        //8. 참조변수 c가 가리키는 x(4번의 참조변수 d가 가리키는 x와 c가 가리키는 x는 같은 객체이다)의 값이 1000으로 저장. x가 10 ->1000 변경
        System.out.println("change() : x = " + c.x); //change() : c = 1000
    } 
}//class
```
<br>
<br>

### 참조형 반환타입 예제
- 참조형은 객체 주소(정수)를 주고 받는다고 생각하면 된다. 
```java
package study;

class Data{ int x; }
class Ex6_6{
    public static void main(String [] args){ //1. main 메서드가 스택에 올라간다. 프로그램 시작
    	
        Data d = new Data();//3.멤버가 x 한개인 Data 객체 생성
        d.x = 10; //2. 참조변수 d가 main 메서드가 있는 스택에 만들어진다. 
        //4. Data 객체의 주소값이 d에 저장되고 참조변수 d가 객체를 가리키게 된다.
        //5. 참조변수 d가 가리키는 객체 멤버 x의 값이 10으로 저장.
        
        Data d2 = copy(d);
        //6. 참조변수 d2가 main 메서드에 있는 스택에 만들어진다.
        //7. copy 메서드가 호출되어 스택의 main 메서드 위에 쌓인다.
        //12. tmp의 반환된 주소값을 d2에 저장하고 d2는 tmp 객체의 x를 가리키게 된다.
        //13. copy 메서드가 종료되어 호출스택에서 사라지고 copy 메서드의 지역변수들도 사라진다.
        
        System.out.println("d.x = " + d.x);// 10
        System.out.println("d2.x = " + d2.x);//10

    }//main

    static Data copy(Data c){
    	//8. 참조형 매개변수 c가 copy 메서드에 생성되고
    	//d의 주소값이 copy 메서드의 참조변수 c에 복사된다.
    	//c는 d의 주소값을 가지고 있으므로 d.x와 같은 x를 가리키게 된다.
       Data tmp = new Data(); //9. 새로운 객체 tmp 생성
       tmp.x = c.x;//10. c가 가리키는 x의 값은 10이고 change 메서드의 참조변수 tmp가 가리키는 x의 값이 10이 된다.
       return tmp;//11. 복사한 객체의 주소를 반환한다.
    } 
}//class
```
### [참고]<br>
```java 
data d2 = (참조변수 생략됨) copy(d);
```
위의 예제에서 copy(d); 메서드는 아래처럼 객체 생성을 하지 않고 참조변수 없이 사용되었다.
```java 
Ex6_8 e = new Ex6_8();
e.copy(d);
```
### copy 메서드 앞에 참조변수가 생략된 이유?<br>
1. copy 메서드가 static 메서드이기 때문에 생략 가능했다.<br> 
    객체 생성없이 호출 가능하다.
2. 같은 클래스에서는 참조변수를 생략할 수 있다.<br>

<br>
<br>

### static 메서드와 인스턴스 메서드

#### - 인스턴스 메서드
    메서드 앞에 static이 없는 메서드
    작업할 때 iv가 필요하기 때문에 인스턴스 생성 후, 인스턴스 멤버와 관련된 작업을 하는 메서드이다.
    당연히 메서드 내에서 인스턴스 변수 사용이 가능하다.
    메서드에 매개변수가 없고, 없으니 iv값을 사용한다. 
    인스턴스 생성 후 호출한다.

    참조변수.메서드이름();

#### - static 메서드 == 클래스 메서드 == 정적 메서드
    메서드 앞에 static이 붙은 메서드
    iv가 필요하지 않기 때문에(=객체가 필요하지 않기 때문에) 객체 생성 없이 사용한다.
    작업에 필요한 값들은 지역변수를 매개변수로 사용하며
    인스턴스 멤버와 관련없는 작업을 하는 메서드이다.
    매서드 내에서 인스턴스 변수 사용이 불가하다.

    클래스명.메서드이름()으로 호출
    예) Math.random(); Math.round();
    예) 클래스이름.메서드이름(매개변수,매개변수...);
    

### 인스턴스 메서드와 static 메서드의 차이점은?
인스턴스 메서드는 반드시 객체를 생성해야만 호출 할 수 있고 <br>
static 메서드는 객체를 생성하지 않고도 호출이 가능하다. <br>
static 메서드 내에서는 인스턴스 변수는 사용할 수 없다. <br>
static 메서드는 인스턴스 생성없이 호출 가능하기 때문에 static 메서드가 호출되었을 때 <br>
인스턴스가 존재하지 않을 수도 있으므로 인스턴스 변수는 사용할 수 없다.<br>

### [중요] 메서드를 직접 만들어 사용할 때 static을 붙일지 말지 정하는 기준?
인스턴스 멤버(iv,im)를 사용하지 않을 때 static을 붙인다!  <br>

[참고] 
객체는 iv의 묶음이다.
메서드는 명령문 집합이다.

### 메서드 간의 호출과 참조
static 메서드는 인스턴스 메서드를 호출 할 수 없다. <br>
인스턴스 메서드는 iv로 작업하며 객체가 필요한데 static 메서드가 인스턴스 메서드를 호출할 때 <br>
인스턴스가 존재하지 않을 수도 있으므로 호출할 수 없다.<br>

### 오버 로딩
:  한 클래스 내에 같은 이름의 메서드를 여러 개 선언하는 것이다.

오버 로딩의 조건
  1) 메서드명이 같아야 한다.
  2) 매개변수의 개수 또는 타입이 달라야 한다.
  3) 반환 타입은 상관없다.

### 오버 라이딩
: 부모 클래스로부터 상속받은 메서드를 재정의하는 것이다.

override 사전적 의미 == overwrite == 위에 덮어쓰다.
오버 라이딩의 조건

  1) 메서드명을 수정하면 안 되고 부모 꺼 그대로 사용해야 한다.
  2) 부모의 매개변수와 동일하게 해야 된다. (개수)
  3) 리턴타입이 동일해야 한다.
  4) 접근지정자는 부모의 접근지정자 범위보다 같거나 넓어야 된다.
  5) 부모의 메서드보다 많은 수의 예외를 선언할 수 없다.
  6) 인스턴스 메서드 <-> static 메서드로 변경 못한다.

### 오버로딩과 오버라이딩의 차이점

오버로딩은 기존에 없는 새로운 메서드를 정의하는 것<br>
오버라이딩은 상속받은 메서드의 내용을 재정의하는 것<br>
<br>
<br>

### 생성자(Constructor)와 기본 생성자(Default Constructor)
생성자 : 인스턴스가 생성될 때마다 호출되는 '인스턴스 초기화 메서드'이다.<br>
                   <<인스턴스 == 객체 == iv묶음>><br>
기본생성자 : 매개변수가 없는 생성자이다.
모든 클래스에는 반드시 하나 이상의 생성자가 선언되어 있어야 한다.<br>
매개변수가 없는 디폴트 생성자는 다른 생성자가 있더라도 항상 만들어 둔다.<br>
```java
클래스이름(타입 변수명, 타입 변수명 ... ){
//인스턴스 생성 시 수행될 코드
//주로 인스턴스 변수의 초기화 코드 작성
}
```
클래스이름은 생성자이름과 같다.
```java
Time t = new Time();
t.hour = 12;
t.minute = 34;
t.second = 56;
```
객체를 생성 후 인스턴스 변수를 초기화했다.<br>
생성자는 따로 선언하지 않았다고 가정하면, 1번 라인의 Time();가 디폴트 생성자호출이다.<br>
(생성자호출이란 생성자를 사용했다는 의미이다.)

```java
Time(int a, int b, int c){ //생성자
hour = a;
minute = b;
second = c;
}
```
생성자를 직접 추가해준다면 객체를 생성할때 아래와 같이 쓸 수 있다.<br>

```java 
Time t = new Time(12,34,56); 
```

여기서도 Time(12,34,56); 부분이 생성자 호출이다.
```
순서는

첫번째. 참조변수 t가 만들어지고
두번째. new 연산자로 객체를 만든다.
세번째. 생성자가 호출되면서 객체를 초기화한다.
초기화는
   12 값이 hour에
   34 값이 minute에
   56 값이 second에 저장되는 것이다.
마지막으로 객체와 참조변수를 연결해야되는데
대입연산자로 객체의 주소(new연산자의 반환값)를 참조변수에 저장하고 참조변수는 객체를 참조하게 된다.
```

### 생성자의 특징 
1) 일종의 메서드이다. (생성자 메서드(함수)라고도 부른다.)
    {}안에 인스턴스 변수 초기화 외에 다른 작업할 문장을 넣으면 그것도 수행한다.
2) 메서드명은 클래스명과 동일해야 한다.
3) 리턴자료형을 사용하지 않으며 리턴문도 사용하지 않는다. (모든 생성자가 리턴값이 없으므로 void는 생략할 수 있게 되었다.)
4) 매개변수가 없는 생성자를 디폴트 생성자(default Constructor)라고 한다. 
5) 접근지정자를 사용할 수 있고, 기타제어자는 사용하지 않는다.
6) 생성자는 임의로 호출할 수 없다.

   객체명.생성자메서드(); 의 식으로 호출되지 않는다.
   #### 그럼 언제 호출될까?
   객체 생성할 때 자동으로 호출된다. 인위적으로 호출이 불가능하다.
   예) new Ex01(); 생성자 호출 (객체 생성할 때 생성자가 내부적으로 호출되기 때문에 () 괄호가 붙는다.)

7) 생성자의 역할은 객체를 생성할 때 자동으로 생성자가 호출되고 필드를 초기화하기 위한 용도로 생성자를 사용한다.
   (주의! 생성자는 인스턴스를 생성하지 않는다. 연산자 new가 인스턴스를 생성하는 것이다.)

8) 생성자는 오버로딩이 가능하다.
   (하나의 클래스에 같은 이름의 여러 개의 생성자가 존재할 수 있다. == 중복선언(중복함수)이 가능하다.)
9) 클래스 선언 시 생성자를 한 개라도 선언하지 않으면 컴파일러가 자동으로 디폴트 생성자를 추가 후 컴파일 한다.
10) 생성자는 상속되지 않는다.

 
#### ※ 디폴트 생성자를 선언하지 않고 생성자를 오버로딩할 때 주의사항

디폴트 생성자가 아닌 생성자가 선언되어 있으면 컴파일러가 자동으로 디폴트 생성자를 추가하지 않는다.
객체 생성할 때 필드를 초기화하거나, 디폴트 생성자를 추가로 선언해준다.
<br>
<br>

### this에는 3가지 사용 용도가 있다.
     1) 멤버를 가리킬 때의 this
     2) 생성자에서 또 다른 생성자를 호출할 때의 this
     3) 단독으로 사용될 때의 this
<br>

1) 멤버를 가리키는 참조변수 this

```java
Point(int x, int y, int z){ //지역변수 x,y,z
	this.x = x; //this.x 는 인스턴스변수
	x = x; //this를 사용하지 않으면 둘 다 지역변수로 간주된다. 
	this.y = y;
	this.z = z;
}
```
생성자의 매개변수로 선언된 변수의 이름이 인스턴스 변수와 이름이 같을 경우 구분이 되지 않는다.<br>
그럴 때 인스턴스의 변수 앞에 this를 사용해 지역변수와 인스턴스 변수를 구별할 수 있다.<br>
이때 this는 인스턴스 자신을 가리키는 참조변수로 인스턴스의 주소가 저장되어 있으며,<br>
생성자와 인스턴스 매서드에서만 사용이 가능하다.<br>
this를 사용할 수 있는 것은 인스턴스멤버뿐이다.<br>

2) 생성자에서 또 다른 생성자를 호출할 때의 생성자 this()
```java
class Car{
	String color;
	String gearType;
	int door;
    
    /*//1번 생성자
    Car(){
    	color = "white";
        gearType = "auto";
        door = 4;
    }*/
    
    Car(){ //2번 생성자
    	//Car("white","auto",4); 여기서 Car 대신 this를 사용한다.
        this("white","auto",4);
    }
    
    Car(String c, String g, int d){ //3번 생성자
    	color = c;
        gearType = g;
        door = d;
    }
}
```

1번 생성자는 3번 생성자와 코드의 중복이 있다.<br>
2번 생성자처럼 this를 사용해 생성자에서 또 다른 생성자를 호출하는 코드를 쓰면 같은 작업을 반복하는 코드의 중복을 제거할 수 있다.<br>
생성자 this는 두가지 조건을 만족해야 호출이 가능하다.<br>
        1.생성자의 이름으로 클래스이름 대신 this를 사용한다.<br>
        2.한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.<br>

3) 단독으로 사용될 때의 this<br>
: 리턴값, 매개변수로 사용될 때 단독으로 사용한다.<br>

<br>
<br>

### 변수의 초기화
지역변수는 사용 전 반드시 수동 초기화 해야한다.<br>
멤버변수(iv, cv)는 기본값으로 자동 초기화된다.<br>

#### 멤버변수의 초기화 방법
1. 명시적 초기화 ( 대입연산자 = )
    - 기본형 변수의 초기화<br>
    ```int door = 4;```
    - 참조형 변수의 초기화<br>
    ```Engine e = new Engine(); //객체를 생성해 e에 넣어준다```

    **참조형 변수가 가질 수 있는 값**<br>
        1. NULL (기본값)<br>
        2. 객체의 주소값<br>

2. 초기화 블럭
    인스턴스 초기화 블럭 : {}<br>
    클래스 초기화 블럭 : static {}<br>

3. 생성자 (iv 초기화)

### 상속
- 특징
기존의 클래스로 새로운 클래스를 작성하는것 
두 클래스를 부모와 자식으로 관계를 맺어주는 것.
자손은 조상(부모의 부모)의 모든 멤버를 상속받는다. (생성자와 초기화 블럭은 제외한다.)
자손의 멤버 개수는 조상보다 적을 수 없다. (같거나 많다)
자손의 변경은 조상에 영향을 미치지 않는다.
