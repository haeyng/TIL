### 객체, 클래스의 개념
**객체지향이론의 기본 개념** : 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다. 실제 세계의 사물의 속성과 기능을 분석하고 변수와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상세계를 구현한다. 객체지향이론의 핵심 개념은 캡슐화, 상속, 추상화, 다형성이다.

객체지향언어는 기존의 절차적 프로그래밍 언어에 객체지향개념의 규칙을 추가한 것이다. 

**OOP(Object Oriented Programming)** : 객체(단위) 지향 프로그래밍 기법이다.<br>
→ OOP의 특징 5가지 - 캡슐화, 은닉화, 상속성, **다형성**, 추상화

**클래스** : 객체를 정의해 놓은 것. 객체를 생성하는데 클래스를 사용한다.

**객체** : 클래스로 실제 존재하는 것. 객체가 가지고 있는 기능과 속성에 따라 사용한다.<br>
속성은 변수로, 기능은 메서드로 표현하며 사물(유형) 또는 개념(무형)의 객체가 있다.

클래스는 쉽게 설계도, 객체는 제품이라고 생각하면 된다.<br>
클래스(설계도)를 가지고 객체(제품)를 만드는데 이것을 '인스턴스화'라고 한다.
<br>
<br>

### 클래스와 객체가 필요한 이유?<br>
- 클래스는 객체(제품)를 생성하기 위해 필요하고<br>
- 객체(제품)는 객체가 가진 속성과 기능을 사용하기 위해 필요하다.

>객체(제품)의 구성요소 : 속성(변수) + 기능(메서드)

객체의 구성요소를 "멤버"라고 부른다.<br>
  - 특징(속성) == property == 멤버변수 == 필드(field)<br>
  - 기능(일) == function == 멤버함수 == 메서드(method)

**객체** : 모든 인스턴스를 대표하는 일반적인 용어<br>
**인스턴스** : 특정 클래스로부터 생성된 객체 (new 연산자에 의해 heap영역에 생성된 객체)

객체와 인스턴스는 비슷한 의미를 가졌다고 보면 될 것 같다.
<br>


### 하나의 소스 파일에 여러 개의 클래스를 작성할 수 있다.
- Tv.java의 소스 파일에 public class가 있는 경우, 소스 파일의 이름은 public class의 이름과 일치해야 한다.
- 하나의 소스파일에 둘 이상의 pulic class가 존재하면 안 된다.<br>
```java
Tv.java 소스 파일에
public class Tv {}  클래스가 선언이 되어 있으면
public class Tv2{}  와 같은 클래스는 선언할 수 없다는 뜻이다.
```
- 클래스명의 첫 글자는 대문자로 시작하고 자바는 대소문자를 구별하기 때문에 틀리지 않도록 주의한다.


### 객체를 생성하는 법<br>
>클래스명 변수명;<br>
변수명 = new 클래스명 ();<br>


```java
Tv t; // Tv 클래스 타입의 참조변수 t 선언
t = new Tv(); // Tv 인스턴스를 생성 후 생성된 Tv 인스턴스의 주소값을 t에 저장
```
  1) Tv 클래스 타입의 참조변수 t 선언
  2) Tv 인스턴스 생성
  3) 생성된 인스턴스의 주소값을 참조변수 t에 저장

  아래처럼 한 문장으로 표현할 수 있다.
```java
Tv t = new Tv();
```
정리하면 객체를 다루려면 반드시 참조변수가 필요하고 참조변수의 타입은 객체(인스턴스)의 타입과 일치해야 한다.<br>
new 연산자가 객체를 만들고 객체의 주소값을 알려주는데 그 주소가 참조변수 t에 저장된다.<br>
(new 연산자에 의해서 heap(동적) 영역에 실제 저장공간이 할당되고 그 주소를 참조한다.)<br>
참조변수 t는 Tv 객체를 가리키고 있다.<br>
(가리키고 있다 == 참조하고 있다)

- 하나의 인스턴스(객체)를 여러 개의 참조변수가 가리키는 것 가능
- 여러 인스턴스(객체)를 하나의 참조변수가 가리키는 것 불가능 (변수는 하나의 값만 저장할 수 있기 때문에)
<br>
<br>

### 그런데 여기서 주소값이 정확히 뭘 의미하는 걸까?<br>
java는 기본형, 참조형이 있다.<br>
기본형은 stack 영역에 직접 값을 가지고 있고, 참조형은 heap 영역의 객체 주소를 stack영역에 가지고 있다.<br>
여기서 말하는 주소값이란 메모리 주소가 아닌 stack 영역에 가지고 있는 heap 영역의 객체 주소이다.<br>

객체는 클래스의 내용대로 만들어지며 주소값만 같다면 두 개 이상의 참조변수가 하나의 객체를 가리키는 것도 가능하다. <br>
객체마다 다른 저장공간을 가지고 있으며 하나의 참조변수가 두 개의 객체를 가리킬(참조할) 수 없다.
<br>
<br>

### 객체를 사용하는 법 (객체가 가진 변수와 메서드를 사용한다.)<br>

```java
t.channel = 7;
```
참조변수 t가 가리키는 객체의 변수 channel에 7을 저장한다.

```java
t.channelDown();
```
참조변수 t가 가리키는 객체의 channelDown이라는 메서드를 호출한다.
해당 메서드의 { } 괄호 안의 문장이 실행된다.
<br>
<br>

### <과정>
1) 클래스(설계도) 작성
2) 객체 생성(제품을 만들고)
3) 객체의 사용(제품을 사용한다.) - 객체가 가진 변수, 메서드를 사용한다.
<br>
<br>

### 클래스를 설계하는 과정<br>
1) 객체의 구성요소 (기능, 속성)를 파악하고 메서드와 필드의 목록을 작성한다.<br>
2) 클래스를 선언한다. <br>
선언형식은<br>
```java
[접근지정자][기타제어자] class 클래스명 [extends Super클래스][implements 인터페이스... 여러개 가능]{
   //필드 선언
   //메서드 선언
}
```
3) 객체를 생성해 테스트한다.<br>
4) 문제점을 파악해 유지, 보수 작업을 한다.<br>
5) 상용화(배포)한다.<br>
6) 기능 추가나 수정과 같은 버전 관리를 한다.<br>
클래스의 멤버를 가리킬 때는 아래처럼 사용한다.<br>

```java
객체명.필드명<br>
객체명.메서드명();
```

멤버에 멤버변수(필드)는 초기화하지 않으면 각 자료형의 기본값으로 초기화되어 있다.<br>
선언 형식 : [접근지정자][기타제어자] 자료형 필드명 [=초기화];  // [] 괄호는 생략이 가능하다.

### 객체 배열 == 참조변수 배열
```java
Tv tv1, tv2, tv3;   ->   Tv [] tvArr = new Tv[3]; //Tv 타입 참조변수 *3
```
![객체배열](https://github.com/haeyng/TIL/assets/141481323/53fc6531-309b-4aaa-b977-dd947226bd1f)

### 클래스는 3가지로 정의할 수 있다.
1. 설계도
2. 데이터 + 함수의 결합
3. 사용자 정의 타입

- 데이터 + 함수의 결합<br>
데이터의 저장 공간에는
1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간(같은 종류만 저장할 수 있다는 한계가 있다.)
3. 구조체 : 서로 관련된 여러 데이터(종류 관계X)를 하나로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합 (구조체 + 함수), 서로 관련있는 것들을 묶음 

- 사용자 정의 타입<br>
클래스로 원하는 타입을 직접 만들 수 있다.

### 선언위치에 따른 변수의 종류
- 클래스 안에는 영역이 2가지 있다.
  1. 클래스영역 - iv(인스턴스 변수), cv(클래스 변수) <br>
  클래스 영역에는 선언문(변수선언, 메서드선언(정의))만 가능하다. (선언문은 순서가 없다.)
  2. 메서드영역 - lv(지역 변수)<br>
<br>
- 3가지 변수
1. 인스턴스 변수 iv : <span style='background-color:#fff5b1'>인스턴스가 생성되었을 때 생성된다.</span><br>
  객체 생성을 해야 사용이 가능하다.<br>
   [참고] 객체는 프로그래밍적인 관점에서 iv를 묶어놓은 것으로 생각해도 된다.<br>
2. 클래스 변수 cv (static + iv) : 클래스가 메모리에 올라갈 때 자동으로 생성된다. <br>
   객체를 생성하지 않아도 아무때나 사용 가능하다.<br>
3. 지역 변수 lv : 변수 선언문이 수행되었을 때 생성되고 블럭이 끝날때까지 사용된다.<br>

### 클래스 변수와 인스턴스 변수
- 개별 속성은 인스턴스 변수를 사용하고 아래와 같은 형식으로 사용한다.
```
참조변수.변수명
```

- 모든 인스턴스가 공통으로 가지는 속성은 클래스 변수를 사용하고 아래와 같은 형식으로 사용한다.
```
클래스명.변수명
```

### 메서드
1. 메서드란 작업 단위로 문장들을 묶어서 이름을 붙인 것이다.
  붙여준 이름으로 메서드를 호출해 코드의 중복을 줄일 수 있다.
2. 값 (입력)을 받아서 처리하고, 결과를 반환(출력)한다.

```java
반환타입 메서드이름 (자료형 매개변수(0 ~ n개 가능)...){
//메서드 호출 시 수행될 코드
//결과를 반환 (0 ~ 1개, 여러개는 배열, 객체로 묶어서하고 0일때는 반환타입에 void를 적어준다.)
}
```

3. 메서드의 장점<br>
  코드의 중복을 줄일 수 있고 관리가 쉽다.<br>
  코드를 재사용할 수 있다.<br>
  코드가 간결해서 이해하기 쉬워진다.<br>

4. 메서드의 작성
반복적으로 수행되는 여러 문장을 메서드로 작성하고 하나의 메서드는 한 가지 기능만 수행하도록 한다.

5. 메서드 호출
```java
메서드이름(값1, 값2, ...)
```
### return문
실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.<br>
반환타입이 void가 아닌 경우 메서드 안에는 반드시 return문이 필요하다.<br>
반환타입과 반환값은 자료형이 일치하거나 자동형변환 가능한 것이어야 한다.<br>
메서드에서 조건문을 사용할 때 참, 거짓 각각 return문을 작성한다.<br>

### 호출 스택(call stack)
스택(stack) : 메서드 수행에 필요한 메모리가 제공되는 공간이다.<br>
```
메서드 호출 -> 호출 스택에 메모리(메서드가 작업을 수행하는데 필요한 메모리)가 할당 -> 
메모리를 사용하며 작업 -> 종료(작업이 끝나면)되면 -> 
호출 스택에서 메모리가 사용하던 메모리 공간이 제거된다.
```
스택은 밑이 막힌 상자의 모양을 떠올린다.<br>
넣어진 순서대로 차곡차곡 쌓이고 꺼낼 때는 마지막으로 넣은 것이 제일 먼저 꺼내진다.<br>

main 메서드가 맨 아래에 있고 메서드가 호출되어 위에 쌓이면<br>
아래에 있는 메서드가 위의 메서드를 호출한 것으로 메서드들 간의 호출 관계를 알 수 있다.<br>
스택에 메서드가 쌓여있어도 가장 맨 위 하나의 메서드만 실행 중이고 나머지는 대기중이다.<br>
